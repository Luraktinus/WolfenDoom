/*

  Base class that allows for handling of Boss Icons, Always-drawn health bars, 
  and for "indiscriminate" enemies to be able to see through player disguises.

  Nazi class inherits from the Base class, so includes the same functionality,
  but also adds properties to configure "sneakability" and "perception".  It 
  also includes handling for Stealth/one-hit knife attacks, and the code for 
  alerting and setting idle sneakable enemies.

  Custom Properties
	Base.BossIcon
	- String property that is used to look up the icon image that is displayed 
	  with the enemy's health bar	
	- Must be used in combination with the +BOSS flag (which enables the boss 
	  health bar to be drawn) or the Base.AlwaysDrawHealthBar property below.
	- Has no effect if the enemy is not flagged to have health bar drawn.

	Base.AlwaysDrawHealthBar
	- Boolean value that is used to tell the game if the enemy's health bar should
	  always be drawn.  
	- Does not require the +BOSS flag to be set, and can alternatively be 
	  controlled via ACS or in-editor by setting the user_DrawHealthBar variable
	- Developer note: This sets the statnum to STAT_DEFAULT - 3
	  (used to limit ThinkerIterator performance hit)

	Base.Swimmer
	- Boolean value that sets whether the actor should be restricted to staying
	  underwater or not.  Used by sharks.

	Base.LoiterDistance
	- Integer value that sets the range from the spawn point that this actor will
	  wander while it is idle (normally only on spawn).  Used by dogs and sharks.

	Nazi.Sneakable
	- Boolean that controls if the enemy is a sneakable enemy or not.
	- Can also be set in-editor on a per-actor basis by setting the user_sneakable
	  variable.
	- Can be set in-game (e.g., after a cutscene using normal actors) by setting
	  the actor's state to "MakeSneakable" via ACS.

	Nazi.PerceptionTime
	- Integer value that controls how many tics a disguised player must remain in 
	  sight of this enemy before the player's disguise fails.
	- Default value is 0, meaning "can't see through disguises"
	- Used by SneakableEyesIdle actor (as seen on sneakable Gestapo)

	Nazi.PerceptionFOV
	- Integer value that controls the FOV of the enemy when trying to see through 
	  player disguises.
	- Used by SneakableEyesIdle actor (as seen on sneakable Gestapo)

  UDMF Properties (Base Class)
	user_drawhealthbar
	- The underlying variable for the Base.AlwaysDrawHealthBar property above

  UDMF Properties (Nazi Class)
	user_sneakable
	- The underlying variable for the Nazi.Sneakable property above

	user_static
	- Actor will remain at its spawn location until the player is within 256 units
	- The actor will still aim and fire at the player, but won't walk toward him
	  until the player is within the 256-unit range

  New Functions (Base class)
	A_LookThroughDisguise(int flags = 0, float minseedist = 0, float Range = 0, float maxheardist = 0, double fov = 0, statelabel label = "See")
	- Allows enemies to always and immediately "see through" player disguises, 
	  essentially by having those enemies ignore the NOTARGET flag when looking 
	  for their target.
	- Parameters are the same as for A_LookEx (https://zdoom.org/wiki/A_LookEx)
	- Should be used in place of A_Look or A_LookEx for "indiscriminate" enemies,
	  that wouldn't be fooled by a disguise, like rats, spiders, and possibly 
	  paranormal creatures.

	A_JumpAttack(int attackspeed = 20)
	- A generic version of A_SkullAttack that allows you to pass in an attack speed
	- Also handles skipping the attack if a swimmer is out of water

	bool InPlayerSight()
	- Checks each player to see if they can see this actor and returns true if any
	  player can see the actor

	actor FindClosestPlayer(int fov = 120, int dist = 0, bool IgnoreFriendlies = True)
	- Finds the closest player within the specified parameter range, and returns
	  the player's mapobject actor.

	bool SneakableActors()
	- Returns true if there are actors flagged as "sneakable" in the current
	  map (Actually just counts StealthBase actors to avoid iterating over all
	  Base or Nazi class descendants and causing huge slowdown).
	- Used internally to set up sneakable handling

	int AlertedSneakablesCount(int range = 512)
	- Returns the number of sneakable actors within the specified range of the 
	  calling actor

  New Functions (Nazi class)
	A_NaziPain(int alertrange = 0, bool playsound = True, int offset = -8)	
	- Consolidated function intended for use in Nazi class Pain states to 
	  eliminate code duplication across actors.
	- Spawns pain overlay (with height offset specified, alerts actors within the
	  passed range, and calls A_Pain if playsound is true.

	BecomeAlerted(Actor newtarget = null)
	- Sets an idle sneakable actor to alerted, spawns alerted helper actor to 
	  continue checking the player's visibility and to manage the return-to-idle 
	  timout counters.
	- Takes one parameter - the new actor to target.
	- Used internally by SneakableEyesIdle actor

	BecomeIdle()
	- Sets an alerted sneakable actor to idle, spawns idle helper actor to look
	  for players and play idle sounds.
	- Also sets actor back to patrolling/goal chasing if a goal had been set 
	  before the actor was alerted
	- Used internally by SneakableEyesAlerted actor

  Useful objects (Nazi Class)
	activationgoal
	- Nazi class descendants have special internal handling in place for when 
	  an actor is assigned as the activationgoal.  
	- Similar to a normal 'goal' that is usually a PatrolPoint, a Nazi will walk 
	  to their activationgoal when it is assigned to them.  The major difference
	  is that Nazis will walk immediately to the activationgoal without stopping
	  to fire at the player, and, once the activationgoal is reached, the goal 
	  actor will activated.  
	- Alarm Panels and their descendants have special handling, where the Nazi 
	  is set to the 'Alarm' state upon activation.
	- After reaching the activationgoal, the Nazi automatically clears their 
	  activationgoal and returns to normal behavior.

*/
// Base class to add ability to see through notarget to actors (e.g., mice, sharks)
class Base : Actor
{
	LookExParams SearchParams;
	String BossIcon;
	bool user_DrawHealthBar;
	bool swimmer;
	int loiterdistance;
	int timeout;
	Actor patrolgoal;
	bool user_conversation;
	Actor marker;
	bool user_ForceWeaponDrop;

	Property BossIcon:BossIcon;
	Property AlwaysDrawHealthBar:user_DrawHealthBar;
	Property Swimmer:swimmer;
	Property LoiterDistance:loiterdistance;

	state A_LookThroughDisguise(int flags = 0, float minseedist = 0, float Range = 0, float maxheardist = 0, double fov = 0, statelabel label = "See")
	{
		// Try a normal look first!
		A_LookEx(flags, minseedist, Range, maxheardist, fov, label);

		if (!target)
		{
			// Set up view parameters for this search
			SearchParams.fov = bLookAllAround ? 360 : fov;
			SearchParams.minDist = minseedist;
			SearchParams.maxDist = Range;
			SearchParams.maxHearDist = Range;

			for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and find one that's in range, ignoring NOTARGET
			{
				Actor mo = players[p].mo;

				if (mo) {
					if (!mo.bShootable || mo.health <= 0) { continue; }
					if (isFriend(mo)) { continue; }
					if (Range && Distance3d(mo) > Range) { continue; }
					if (!IsVisible(mo, false, SearchParams)) { continue; }

					let disguise = mo.FindInventory("DisguiseToken", True);
					if (!disguise) { continue; }

					target = mo;
					return ResolveState(label);
				}
			}
		}

		return ResolveState(null);
	}

	void A_JumpAttack(int attackspeed = 20)
	{
		if (!target || (swimmer && target.waterlevel == 0)) { return; }

		bSkullFly = true;
		A_PlaySound(AttackSound, CHAN_VOICE);
		A_FaceTarget();

		VelFromAngle(attackspeed);
		Vel.Z = (target.pos.Z + target.Height / 2 - pos.Z) / DistanceBySpeed(target, attackspeed);
	}

	bool InPlayerSight()
	{
		for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and see if any can see the spawn point
		{
			Actor mo = players[p].mo;

			if (mo) {
				if (mo.CheckSight(self)) { return true; }
			}
		}

		return false;
	}

	Actor FindClosestPlayer(int fov = 120, int dist = 0, bool IgnoreFriendlies = True) // Also sets up initial sight parameters
	{
		Actor ClosestPlayer = null;

		LookExParams SearchParams;

		SearchParams.fov = fov;
		SearchParams.minDist = 0;
		SearchParams.maxDist = dist;
		SearchParams.maxHearDist = dist;

		for (int p = 0; p < MAXPLAYERS; p++) { // Iterate through all of the players and find the closest one
			Actor mo = players[p].mo;

			if (mo) {
				if (!mo.bShootable || mo.health <= 0) { continue; }
				if (players[p].cheats & CF_NOTARGET) { continue; }
				if (!IsVisible(mo, false, SearchParams)) { continue; }
				if (IgnoreFriendlies) { if (isFriend(mo)) { continue; } }
				if (ClosestPlayer && Distance3d(mo) > Distance3d(ClosestPlayer)) { continue; }

				ClosestPlayer = mo;
			}
		}
		return ClosestPlayer;
	}

	bool SneakableActors() // Are there sneakable actors in the level?
	{
		ThinkerIterator it = ThinkerIterator.Create("StealthBase", Thinker.STAT_DEFAULT - 2); // Just iterate over the sneakable eyes - faster than all Nazi actors
		StealthBase mo;
		while (mo = StealthBase(it.Next(true)))
		{
			return true;
		}

		return false;
	}

	int AlertedSneakablesCount(int range = 512)
	{
		ThinkerIterator it = ThinkerIterator.Create("SneakableGuardEyesAlerted", Thinker.STAT_DEFAULT - 2);
		SneakableGuardEyesAlerted mo;

		int count = 0;
		while (mo = SneakableGuardEyesAlerted(it.Next(true)))
		{
			if (Distance3d(mo) > range) { continue; }

			count++;
		}
		return count;
	}

	override void Tick()
	{
		if (user_DrawHealthBar) { ChangeStatNum(Thinker.STAT_DEFAULT - 3); } // Change the statnum of these actors so that ThinkerIterators can look at just this statnum and be more efficient

		if (!globalfreeze && !level.Frozen)
		{
			if (swimmer && waterlevel < 3)
			{
				vel.z = min(vel.z, -1);
			}

			if (bShootable && health > 0)
			{
				if (loiterdistance > 0 && patrolgoal && !bAmbush)
				{
					if (goal && goal != patrolgoal) { } // Already has a goal set, so don't mess with it
					else if (!target || (target == patrolgoal))
					{
						if (Distance3d(patrolgoal) > loiterdistance)
						{
							goal = patrolgoal;
							target = goal;

							if (timeout <= 0)
							{
								RandomChaseDir();
								FaceMovementDirection();

								timeout = 35;
							}
						}
		 				else
						{
							goal = null;
							target = null;
						}
					}
				}
				timeout--;
			}

			if (bInConversation && marker)
			{
				marker.SetStateLabel("Inactive");
				marker = null;
			}
		}

		Super.Tick();
	}

	override void PostBeginPlay()
	{
		// After initilization, handle skill level health alterations
		//   For each each skill level below 'normal', reduce enemy health by specified percentage
		//     So, for an enemy with 25 health normally, at the second skill level, it would have 16,
		//     and at the first skill level it would have 10 (~66% of 16) (assuming the multiplier is 2/3)
		//     This effectively takes a doberman from 3 hits with the knife to 2 on skill 1, to 1 on skill 0.

		double multiplier = 2. / 3; // Cut the health down to 2/3 its value for each skill level below normal

		if (skill < 2) { // If skill 0 or 1
			int newhealth = health;

			// Reduce the health by 1/3 for each skill level below normal
			for (int i = 0; i < 2 - skill; i++) { newhealth = int(newhealth * multiplier); }

			// Set the actor's health - cap minimum at 1 so that they don't die, just in case
			A_SetHealth(max(newhealth, 1));
		}

		// If it's a loiterer with no set goal, spawn a patrolpoint goal for it and make that the goal, then run around that point
		if (loiterdistance > 0 && !goal && !patrolgoal) 
		{
			patrolgoal = Spawn("PatrolPoint", pos);
			patrolgoal.args[0] = -1;
			patrolgoal.args[1] = 0x7FFFFFFF;
			patrolgoal.angle = angle;

			SetStateLabel("See");
		}

		// If it's tagged with a conversation ID, spawn the conversation marker
		if (user_conversation && !marker)
		{
			marker = Spawn("ConversationMarker", pos);
			if (marker) { marker.master = self; }
		}
	}
}

// Base class for almost all enemy actors.
// Adds handling for 'sneakable' actors and stealth/critical hit kills
class Nazi : Base
{
	int user_incombat;
	int perceptionthreshold;
	int perceptionfov;
	int user_chasegoal;
	int sneakableclosesightradius;
	bool user_sneakable;
	String DeathDamageType;
	Actor activationgoal;
	int user_static;
	state AimState;
	bool healing;

	Property Sneakable:user_sneakable;
	Property SneakableCloseSightRadius:sneakableclosesightradius;
	Property PerceptionTime:perceptionthreshold; // How many tics the player has to be in sight before NOTARGET fails - 0 means never see through NoTarget
	Property PerceptionFOV:perceptionfov; // FOV used for NOTARGET sight checks (i.e., Gestapo and others who can see through scientist/gestapo uniforms)

	Default
	{
		Monster;
		+BOSSDEATH
		+CANBLAST //needed for kicks - ozy81
		+DONTGIB
		+DONTHARMSPECIES
		+FLOORCLIP
		+NOINFIGHTSPECIES
		+WINDTHRUST
		DamageFactor "Frag", 1.2; //increased damage from grenades & clusterbombs for Nazi related enemies - this fix TurretSoldiers [ozy81]
		Scale 0.65;
		Height 56;
		Mass 100;
		PainChance 200;
		Speed 2;
		Species "Nazi";

		Nazi.Sneakable False;
		Nazi.SneakableCloseSightRadius 64;
		Nazi.PerceptionTime 0;
		Nazi.PerceptionFOV 120;
	}

	States
	{
		Look:
			"####" "#" 10 A_Look();
			Loop;
		See: 
		See.Normal: // Guard Walk Pattern
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" DDD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); } // Jump to the actor's defined See state so any special handling can still happen each loop
		See.Fast: // SS Walk Pattern
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" BB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" DD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.Faster: // Officer Walk Pattern
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" A 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" A 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.MutantFaster: // Mutant Walk Pattern (same as Faster, but with steps on opposite frames)
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" A 1 A_NaziChase(null, null);
			"####" A 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" A 1 A_NaziChase;
			"####" A 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" C 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.MutantFasterAlt: // Mutant Walk Pattern, offset frames (BCDE walk instead of ABCD)
			"####" "#" 0 { user_incombat = True; }
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" E 1 A_NaziChase;
			"####" E 1 A_NaziChase(null, null);
			"####" E 1 A_NaziChase;
			"####" E 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.Boss: // Almost all bosses
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" B 0 A_PlaySound("floor/heavy");
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" D 0 A_PlaySound("floor/heavy");
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.BossFast: // Faster bosses, like UberMutant
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" B 0 A_PlaySound("floor/heavy");
			"####" B 1 A_NaziChase;
			"####" BB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" D 0 A_PlaySound("floor/heavy");
			"####" D 1 A_NaziChase;
			"####" DD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.BossMech: // Mechs - same as Boss, but with quake and mech sound
			"####" "#" 0 { user_incombat = True; }
			"####" A 2 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" B 0 A_PlaySound("mech/walk", CHAN_AUTO, frandom(0.7,1.0), FALSE, ATTN_IDLE);
			"####" B 2 { A_NaziChase(); Radius_Quake(5, 2, 0, 5, 0); }
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" C 2 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" D 2 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" C 0 A_PlaySound("mech/walk", CHAN_AUTO, frandom(0.5,0.7), FALSE, ATTN_IDLE);
			"####" C 2 { A_NaziChase(); Radius_Quake(5, 2, 0, 5, 0); }
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" B 2 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.Static: // Sniper Walk Pattern (non-moving, limited frame actor)
			"####" "#" 0 { user_incombat = True; }
			"####" "#" 1 A_Chase;
			"####" A 0 { return ResolveState("See"); }
		Idle:
			"####" AAAAAAAA 1 A_Wander;
			"####" A 0 A_Look;
			"####" BBBBBBBB 1 A_Wander;
			"####" A 0 A_Look;
			"####" CCCCCCCC 1 A_Wander;
			"####" A 0 A_Look;
			"####" DDDDDDDD 1 A_Wander;
			"####" A 0 A_Look;
			Loop;
		Pain:
			"####" H 6 A_NaziPain(256);
			"####" H 0 A_Jump(256,"See");
		MakeSneakable:
			"####" # 0 {
				if (health <= 0 || !bShootable) { return ResolveState('null'); } // If it's dead, don't make a zombie, just remove it and hope no one notices...

				user_sneakable = true;
				BeginPlay();

				return ResolveState("Spawn");
			}
		MakeAlerted:
			"####" # 0 {
				BecomeAlerted(target);
				return ResolveState("See");
			}
		Alarm:
			"####" H 50 A_SetTics(Random[AlarmWait](35, 70));
			"####" H 0 A_Jump(256, "See");
	}

	// Function to consolidate default pain state actions.  See use above - can be used to eliminate a lot of existing copy/paste.
	void A_NaziPain(int alertrange = 0, bool playsound = True, int offset = -8)
	{
		A_SpawnItemEx("Pain_Overlay", scale.x + 3, 0, height + offset, 0, 0, 0, 0, SXF_NOCHECKPOSITION | SXF_USEBLOODCOLOR); // Spawn pain overlay blood spurt
		if (alertrange) { A_AlertMonsters(alertrange); } // Alert monsters in given range
		if (playsound) { A_Pain(); } // Play pain sound unless passed 'false'

		if (user_sneakable && bFriendly) // If we attacked a sneakable actor who wasn't alerted...
		{
			BecomeAlerted(target); // Alert that actor
		}
	}

	void A_NaziChase(statelabel melee = "None", statelabel missile = "None", int flags = 0)
	{
		if (melee == "None") { melee = "Melee.Aimed"; }
		if (missile == "None") { missile = "Missile.Aimed"; }

		if (target && Distance3D(target) < 256) { user_static = 0; }

		if (AimState && (user_static || bAmbush))
		{
			flags |= CHF_DONTMOVE | CHF_NODIRECTIONTURN;

			frame = AimState.frame;
			A_SetTics(Random[StandDelay](1, 5));

			A_FaceTarget();
			reactiontime = 0;
		}

		A_Chase(melee, missile, flags);
	}

	// Initialize actor
	override void BeginPlay()
	{
		// If it's sneakable, spawn a set of the sneakeable eyes and mark it as friendly (and make the actor never infight)
		if (user_sneakable) {
			bFriendly = True;
			bNeverTarget = True; // A bit of a hack, but it works...  Will cause issues if FRIENDLY actors ever need to interact with sneakable actors
			A_SpawnItemEx("SneakableGuardEyesIdle", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid);
			ChangeStatNum(Thinker.STAT_DEFAULT - 5); // Make these tic before the alert lights for checking logic purposes
		}
		else if (SneakableActors()) // If there are sneakable actors in the level, no Nazi actors will be targetable - fixes targeting of non-sneakables by idle (friendly) sneakables
		{ // This will break normal expected friendly monster behavior!
			bNeverTarget = True;
		}

		// Set the actor's aim state (first frame of attack animation) for static and AMBUSH actors
		AimState = FindState("Missile.Aimed");
		if (!AimState) { AimState = FindState("Melee.Aimed"); }
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		// Use the aim state frame as the initial frame if they have the AMBUSH flag
		if (AimState && bAmbush) { frame = AimState.frame; }
	}

	// Hijack the damage calls in order to implement stealth kills and critical hits
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags = 0, double angle = 0)
	{
		if (user_sneakable && bDormant) { bDormant = False; } // Pain wakes up a dormant sneakable actors

		String currentDamage = (inflictor && inflictor.paintype) ? inflictor.paintype : mod; // Get the damage type

		if (currentDamage ~== "SilentKnifeAttack" && !bBoss) // If the attack was with the knife (and this is not a boss actor - they can't be one-hit killed!)
		{
			if (user_sneakable && bFriendly) // If this is a sneakable actor who isn't active yet
			{ // Stealth kill, remove the sneakable eyes, alert a medium radius, and kill the actor
				A_Log(StringTable.Localize("$STEALTH"));
				A_RemoveChildren(TRUE, RMVF_EVERYTHING);
				bFriendly = False; // Force to not friendly so that they will count as a kill and be healable.
				SoundAlert(source, false, 192);
				A_Die();
			}
			else if (user_incombat) // If the actor has already been in its See state
			{
				A_PlaySound("Nazi1/Pain", CHAN_AUTO, FRandom(0.2, 0.4), FALSE, ATTN_NORM); // Play quiet pain sound
				SoundAlert(source, false, 64); //ozy - only if near // Alert small radius
			}
			else // Otherwise, this attack was the equivalent of Stealth Kill for non-sneakable enemies
			{
				user_incombat = True;
				A_Log(StringTable.Localize("$CRITICAL"));
				SoundAlert(source, false, 192);
				A_Die();
			}
		}

		ACS_NamedExecuteAlways("AddExtraVisibility", 0, 200, 1); // Attacking always makes visibility increase significantly

		if (user_sneakable && bFriendly) // If we attacked a sneakable actor who wasn't alerted...
		{
			BecomeAlerted(source); // Alert that actor
		}

		int damageamt = Super.DamageMobj(inflictor, source, damage, mod, flags, angle); // Get the damage amount from the real DamageMobj function

		if (damageamt >= health) // If we killed the actor...
		{
			if (user_sneakable) // and it was a sneakable actor...
			{
				A_RemoveChildren(TRUE, RMVF_EVERYTHING); // Remove the sneakable eyes
			}

			if (perceptionthreshold > 0) // or if it was a perceptive actor...
			{
				if (BoAPlayer(source)) { BoAPlayer(source).suspicion = 0; } // Reset suspicion level to zero
			}

			DeathDamageType = currentDamage;
		}

		target = source; // Set the attacker as the current target

		return damageamt; // Function returns amount of damage received by the actor
	}

	// Handling for alerting sneakable actors
	void BecomeAlerted(Actor newtarget = null)
	{
		if (health <= 0 || !bShootable) { return; } // If it's dead, don't do anything

		A_SpawnItemEx("AlertMarker", 0, 0, 64, 0, 0, 0, 0, SXF_SETMASTER);
		if (!bBoss) { A_PlaySound("axis1/sighted", CHAN_BODY); }
		else { A_PlaySound(SeeSound, CHAN_BODY); }

		A_RemoveChildren(TRUE, RMVF_EVERYTHING, "None", "Eyes"); // Get rid of the passive guard eyes
		bFriendly = False; // Set unfriendly

		if (goal)
		{
			patrolgoal = goal; // Save the navigation goal if one was set
		}

		if (!patrolgoal) // Otherwise, make a new navgoal at the actor's origin so that it can come back.
		{
			patrolgoal = Spawn("PatrolPoint", pos);
			patrolgoal.args[0] = -1;
			patrolgoal.args[1] = 0x7FFFFFFF;
			patrolgoal.angle = angle;
		}

		target = newtarget; // Set target to the player the eyes saw

		if (activationgoal && newtarget && CheckSight(newtarget)) {
			goal = activationgoal;
			target = activationgoal;
			LastEnemy = newtarget;
			bChaseGoal = True;
		}

		reactiontime = 0; // Make the enemy respond to seeing the player right away
		A_AlertMonsters(512); // Alert an extra-large radius
		A_SpawnItemEx("SneakableGuardEyesAlerted", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid); // Spawn active guard eyes
		if (target && target.GetSpecies() == GetSpecies()) { target = null; SetStateLabel("Spawn"); } // Don't go after same-species targets
		SetStateLabel("See"); // Go to See state and start chasing the player (or wandering if target wasn't set for some reason)
	}

	void BecomeIdle()
	{
		if (health <= 0 || !bShootable) { return; }

		A_RemoveChildren(TRUE, RMVF_EVERYTHING, "None", "Eyes"); // Get rid of the active guard eyes
		bFriendly = True;

		goal = patrolgoal; // Restore any navigation goal if there was one set
		target = patrolgoal;

		A_SpawnItemEx("SneakableGuardEyesIdle", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid);

		if (goal && target) { SetStateLabel("See"); }
		else { SetStateLabel("Spawn"); }
	}

	void A_UnblockAndDrop()
	{
		if (user_ForceWeaponDrop)
		{
			DropItem drops = GetDropItems();
			DropItem item;

			if (drops != null)
			{
				for (item = drops; item != null; item = item.Next)
				{
					String itemName = String.Format("%s", item.Name); // Don't know why I have to do this and the Length check, but 'DropItem ""' crashes without it, even if I check for != "", != null, etc...
					if (itemName.Length() > 0 && item.Name != 'None')
					{
						Actor drop = Spawn(item.Name); // See if it spawns in order to validate the name...  Since there's no FindClass function exposed?

						if (drop is "Weapon") // If it is a weapon, drop the item
						{
							int amt = item.Amount;

							A_DropItem(item.Name, amt); 
						}

						drop.Destroy(); // Destroy the placeholder spawned item
					}
				}
			}

			A_NoBlocking(False); // Set A_NoBlocking with no additional item drops.
		}
		else
		{
			A_NoBlocking(!user_sneakable); // Otherwise, unblock and do normal drops, excluding any drops from sneakables.
		}
	}

	override void Tick()
	{
		// If the enemy is sneakable and idle (and not patrolling), and isn't in its original location, keep it moving toward that location.
		//  NOTE: This doesn't work properly when the player has NOTARGET enabled (or is wearing a disguise and has no weapon raised).
		if (health > 0 && bShootable)
		{
			if (user_sneakable && bFriendly && patrolgoal && patrolgoal.args[0] == -1)
			{
				activationgoal = null;
				if (Distance3D(patrolgoal) <= Radius) // If at goal, clear target and goal and go to Spawn state
				{
					goal = null;
					LastHeard = null;
					LastEnemy = null;
					A_ClearTarget();
					SetStateLabel("Spawn");
				}
				else // Otherwise, keep trying to get there (necessary because A_Chase clears goal and target when within MeleeRange of goal)
				{
					goal = patrolgoal;
					target = patrolgoal;
					if (!InStateSequence(CurState, SeeState)) { SetStateLabel("See"); }
				}
			}
			else if (!bFriendly && activationgoal && user_incombat)
			{
				if (Distance3D(activationgoal) <= Radius + activationgoal.radius) 
				{
					A_Face(activationgoal);

					target = LastEnemy;
					LastEnemy = null;

					activationgoal.Activate(target);

					bJustAttacked = False;
					bChaseGoal = False;
					Speed = Default.Speed;

					if (activationgoal is "AlarmPanel") { SetStateLabel("Alarm"); }

					activationgoal = null;
				}
				else // Otherwise, keep trying to get there
				{
					if (goal != activationgoal || (LastEnemy && CheckSight(LastEnemy)))
					{
						goal = activationgoal; // Set the activation goal as the current navigation goal
						bJustAttacked = True; // Keep the actor from attacking while chasing to the goal
						bChaseGoal = True; // Chase to the goal only, not torward a target
						Speed = Default.Speed + 1; // Walk a little faster
						if (!InStateSequence(CurState, SeeState)) { SetStateLabel("See"); } // Go to the See state if not already there
					}
				}
			}
		}

		Super.Tick();
	}
}

//Standard Nazi enemy defaults.  
//  Intended for use with 'normal' non-boss Nazi enemies.
//  Currently handles burning, gibbing, and disintegration states
class NaziStandard : Nazi
{
	Default
	{
		GibHealth 30;
		SeeSound "Nazi1/Sighted";
		PainSound "Nazi1/Pain";
		DeathSound "Nazi1/Death";
	}

	States
	{
		Salute: //special state for cinematic sequences - ozy81
			"####" N 35;
		SaluteLoop:
			"####" Z 35;
			Loop;
		Death.Fire:
			"####" # 0 A_SetScale(0.55);
		Death.Fire.Random: // Jump to here if you have an actor that needs a different scale set (See WereWaffenSS)
			"####" # 0 {
				DeathDamageType = "Fire"; // Because the flamethrower guards are set to this state via jump, not damage
				sprite = GetSpriteIndex(Random() < 128 ? "BURN" : "NRUB");
				bIsMonster = False; // Burned enemies can't be resurrected
			}
			"####" A 5 Bright Light("ITBURNS1") { A_Wander(); }
			"####" BC 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); }
			"####" D 5 Bright Light("ITBURNS1") { A_Wander(); A_PlaySound("death/burning"); }
			"####" E 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); }
			"####" FABCD 5 Bright Light("ITBURNS2") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); }
			"####" EFAG 5 Bright Light("ITBURNS3") A_Wander();
			"####" H 5 Bright Light("ITBURNS3") A_UnblockAndDrop();
			"####" IJK 5 Bright Light("ITBURNS2") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,16), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
			"####" LMN 5 Bright Light("ITBURNS1") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,8), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
			"####" O -1;
			Stop;
		Raise:
			"####" # 35 { A_SetTics(Default.Health > 25 ? min(Default.Health / 25, 3) * 35 : 35); } // To match the medic's healing state duration
			"####" M 35;
			"####" LKJ 5;
			"####" I 5 A_Jump(256,"See");
			Stop;
		XDeath:
			SLOP A 5 {
				A_SpawnItemEx("NashGore_FlyingBlood", 0, 0, 8, random(-4, 4), random(-4, 4), random(2, 5), 0, 143, 176);
				A_SetScale(0.65);
				bIsMonster = False; // So that an exploded enemy can't be resurrected
			}
			"####" BCDE 5;
			"####" F 5 A_UnblockAndDrop();
			"####" G -1;
			Stop;
		Disintegrate:
			"####" H 5 {
				A_Scream();
				A_Playsound("astrostein/guard_death");
				A_UnblockAndDrop();
				A_SpawnItemEx("BaseLine", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
			}
		Disintegrate.FadeLoop:
			"####" H 1 A_FadeOut(0.02);
			Loop;
		SpriteLookups: // Because the GetSpriteIndex function won't find sprites that aren't already used by a state in the current actor.
			BURN A 0;
			NRUB A 0;
	}
}

// Conversation marker that follows the actor, positioning itself above their head.
//  For Invisible/NoBlockMap actors, the marker is placed at the base of the actor.
class ConversationMarker : Actor
{
	Default
	{
		+BRIGHT
		+NOBLOCKMAP
		+NOGRAVITY
		Height 0;
		Radius 0;
		Scale 1.35;
		RenderStyle "Translucent";
		Alpha 1.0;
	}

	States
	{
		Spawn:
		Active:
			EXCL D 1 BRIGHT;
			Loop;
		Inactive:
			EXCL D 10 BRIGHT;
			EXCL E -1 BRIGHT;
			Stop;
	}

	override void Tick()
	{
		if (master)
		{
			if (master.health <= 0) { Destroy(); }
			else
			{
				double offset;

				if (master.bInvisible || master.bNoBlockMap) { offset = 12; }
				else { offset = master.height + 12; }

				SetOrigin((master.pos.x, master.pos.y, master.pos.z + offset), true);
			}
		}

		Super.Tick();
	}
}