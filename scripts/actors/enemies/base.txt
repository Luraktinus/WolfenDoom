/*

  Base class that allows for handling of Boss Icons, Always-drawn health bars,
  and for "indiscriminate" enemies to be able to see through player disguises.

  Nazi class inherits from the Base class, so includes the same functionality,
  but also adds properties to configure "sneakability" and "perception".  It
  also includes handling for Stealth/one-hit knife attacks, and the code for
  alerting and setting idle sneakable enemies.

  Custom Properties
	Base.BossIcon
	- String property that is used to look up the icon image that is displayed
	  with the enemy's health bar
	- Must be used in combination with the +BOSS flag (which enables the boss
	  health bar to be drawn) or the Base.AlwaysDrawHealthBar property below.
	- Has no effect if the enemy is not flagged to have health bar drawn.

	Base.AlwaysDrawHealthBar
	- Boolean value that is used to tell the game if the enemy's health bar should
	  always be drawn.
	- Does not require the +BOSS flag to be set, and can alternatively be
	  controlled via ACS or in-editor by setting the user_DrawHealthBar variable
	- Developer note: This sets the statnum to STAT_DEFAULT - 3
	  (used to limit ThinkerIterator performance hit)

	Base.Swimmer
	- Boolean value that sets whether the actor should be restricted to staying
	  underwater or not.  Used by sharks.

	Base.LoiterDistance
	- Integer value that sets the range from the spawn point that this actor will
	  wander while it is idle (normally only on spawn).  Used by dogs and sharks.

	Nazi.Sneakable
	- Boolean that controls if the enemy is a sneakable enemy or not.
	- Can also be set in-editor on a per-actor basis by setting the user_sneakable
	  variable.
	- Can be set in-game (e.g., after a cutscene using normal actors) by setting
	  the actor's state to "MakeSneakable" via ACS.

	Nazi.PerceptionTime
	- Integer value that controls how many tics a disguised player must remain in
	  sight of this enemy before the player's disguise fails.
	- Default value is 0, meaning "can't see through disguises"
	- Used by SneakableEyesIdle actor (as seen on sneakable Gestapo)

	Nazi.PerceptionFOV
	- Integer value that controls the FOV of the enemy when trying to see through
	  player disguises.
	- Used by SneakableEyesIdle actor (as seen on sneakable Gestapo)

  UDMF Properties (Base Class)
	user_drawhealthbar
	- The underlying variable for the Base.AlwaysDrawHealthBar property above

  UDMF Properties (Nazi Class)
	user_sneakable
	- The underlying variable for the Nazi.Sneakable property above

	user_static
	- Actor will remain at its spawn location until the player is within 256 units
	- The actor will still aim and fire at the player, but won't walk toward him
	  until the player is within the 256-unit range

  New Functions (Base class)
	A_LookThroughDisguise(int flags = 0, float minseedist = 0, float Range = 0, float maxheardist = 0, double fov = 0, statelabel label = "See")
	- Allows enemies to always and immediately "see through" player disguises,
	  essentially by having those enemies ignore the NOTARGET flag when looking
	  for their target.
	- Parameters are the same as for A_LookEx (https://zdoom.org/wiki/A_LookEx)
	- Should be used in place of A_Look or A_LookEx for "indiscriminate" enemies,
	  that wouldn't be fooled by a disguise, like rats, spiders, and possibly
	  paranormal creatures.

	A_JumpAttack(int attackspeed = 20)
	- A generic version of A_SkullAttack that allows you to pass in an attack speed
	- Also handles skipping the attack if a swimmer is out of water

	A_WanderGoal()
	- If the enemy has a goal assigned, go to it.  If not, wander.

	bool InPlayerSight()
	- Checks each player to see if they can see this actor and returns true if any
	  player can see the actor

	actor FindClosestPlayer(int fov = 120, int dist = 0, bool IgnoreFriendlies = True)
	- Finds the closest player within the specified parameter range, and returns
	  the player's mapobject actor.

	bool SneakableActors()
	- Returns true if there are actors flagged as "sneakable" in the current
	  map (Actually just counts StealthBase actors to avoid iterating over all
	  Base or Nazi class descendants and causing huge slowdown).
	- Used internally to set up sneakable handling

	int AlertedSneakablesCount(int range = 512)
	- Returns the number of sneakable actors within the specified range of the
	  calling actor

  New Functions (Nazi class)
	A_NaziPain(int alertrange = 0, bool playsound = True, int offset = -8)
	- Consolidated function intended for use in Nazi class Pain states to
	  eliminate code duplication across actors.
	- Spawns pain overlay (with height offset specified, alerts actors within the
	  passed range, and calls A_Pain if playsound is true.

	BecomeAlerted(Actor newtarget = null)
	- Sets an idle sneakable actor to alerted, spawns alerted helper actor to
	  continue checking the player's visibility and to manage the return-to-idle
	  timout counters.
	- Takes one parameter - the new actor to target.
	- Used internally by SneakableEyesIdle actor

	BecomeIdle()
	- Sets an alerted sneakable actor to idle, spawns idle helper actor to look
	  for players and play idle sounds.
	- Also sets actor back to patrolling/goal chasing if a goal had been set
	  before the actor was alerted
	- Used internally by SneakableEyesAlerted actor

  Useful objects (Nazi Class)
	activationgoal
	- Nazi class descendants have special internal handling in place for when
	  an actor is assigned as the activationgoal.
	- Similar to a normal 'goal' that is usually a PatrolPoint, a Nazi will walk
	  to their activationgoal when it is assigned to them.  The major difference
	  is that Nazis will walk immediately to the activationgoal without stopping
	  to fire at the player, and, once the activationgoal is reached, the goal
	  actor will activated.
	- Alarm Panels and their descendants have special handling, where the Nazi
	  is set to the 'Alarm' state upon activation.
	- After reaching the activationgoal, the Nazi automatically clears their
	  activationgoal and returns to normal behavior.

*/
// Base class to add ability to see through notarget to actors (e.g., mice, sharks)
class Base : Actor
{
	LookExParams SearchParams;
	String BossIcon;
	bool user_DrawHealthBar;
	bool swimmer;
	int loiterdistance;
	int timeout;
	Actor patrolgoal;
	bool user_conversation;
	Actor marker;
	bool user_ForceWeaponDrop;
	int dodgetimeout;
	int dodgecounter;
	int maxdodge;
	State DodgeState;

	Property BossIcon:BossIcon;
	Property AlwaysDrawHealthBar:user_DrawHealthBar;
	Property Swimmer:swimmer;
	Property LoiterDistance:loiterdistance;
	Property DodgeAmount:maxdodge; // Max number of times the enemy will dodge

	state A_LookThroughDisguise(int flags = 0, float minseedist = 0, float Range = 0, float maxheardist = 0, double fov = 0, statelabel label = "See")
	{
		// Try a normal look first!
		A_LookEx(flags, minseedist, Range, maxheardist, fov, label);

		if (!target)
		{
			// Set up view parameters for this search
			SearchParams.fov = bLookAllAround ? 360 : fov;
			SearchParams.minDist = minseedist;
			SearchParams.maxDist = Range;
			SearchParams.maxHearDist = Range;

			for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and find one that's in range, ignoring NOTARGET
			{
				Actor mo = players[p].mo;

				if (mo) {
					if (!mo.bShootable || mo.health <= 0) { continue; }
					if (isFriend(mo)) { continue; }
					if (Range && Distance3d(mo) > Range) { continue; }
					if (!IsVisible(mo, false, SearchParams)) { continue; }

					let disguise = mo.FindInventory("DisguiseToken", True);
					if (!disguise) { continue; }

					target = mo;
					return ResolveState(label);
				}
			}
		}

		return ResolveState(null);
	}

	void A_JumpAttack(int attackspeed = 20)
	{
		if (!target || (swimmer && target.waterlevel == 0)) { return; }

		bSkullFly = true;
		A_PlaySound(AttackSound, CHAN_VOICE);
		A_FaceTarget();

		VelFromAngle(attackspeed);
		Vel.Z = (target.pos.Z + target.Height / 2 - pos.Z) / DistanceBySpeed(target, attackspeed);
	}

	void A_WanderGoal(int flags = 0, int scarerange = 0)
	{
		if (scarerange > 0 && lastheard)
		{
			if (Distance3D(lastheard) <= scarerange)
			{
				bFrightened = True;
			}
			else
			{
				bFrightened = False;
				lastheard = null;
			}
		}

		if (goal != null)
		{
			target = goal;
			bChaseGoal = true;
			A_Chase(null, null, flags);
		}
		else
		{
			bChaseGoal = Default.bChaseGoal;
			A_Wander(flags);
		}
	}

	bool InPlayerSight()
	{
		for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and see if any can see the spawn point
		{
			Actor mo = players[p].mo;

			if (mo) {
				if (mo.CheckSight(self, SF_SEEPASTBLOCKEVERYTHING | SF_SEEPASTSHOOTABLELINES)) { return true; }
			}
		}

		return false;
	}

	Actor FindClosestPlayer(int fov = 120, int dist = 0, bool IgnoreFriendlies = True) // Also sets up initial sight parameters
	{
		Actor ClosestPlayer = null;

		LookExParams SearchParams;

		SearchParams.fov = fov;
		SearchParams.minDist = 0;
		SearchParams.maxDist = dist;
		SearchParams.maxHearDist = dist;

		for (int p = 0; p < MAXPLAYERS; p++) { // Iterate through all of the players and find the closest one
			Actor mo = players[p].mo;

			if (mo) {
				if (!mo.bShootable || mo.health <= 0) { continue; }
				if (players[p].cheats & CF_NOTARGET) { continue; }
				if (!IsVisible(mo, false, SearchParams)) { continue; }
				if (IgnoreFriendlies) { if (isFriend(mo)) { continue; } }
				if (ClosestPlayer && Distance3d(mo) > Distance3d(ClosestPlayer)) { continue; }

				ClosestPlayer = mo;
			}
		}
		return ClosestPlayer;
	}

	bool SneakableActors() // Are there sneakable actors in the level?
	{
		ThinkerIterator it = ThinkerIterator.Create("StealthBase", Thinker.STAT_DEFAULT - 2); // Just iterate over the sneakable eyes - faster than all Nazi actors
		StealthBase mo;
		while (mo = StealthBase(it.Next(true)))
		{
			return true;
		}

		return false;
	}

	int AlertedSneakablesCount(int range = 512)
	{
		ThinkerIterator it = ThinkerIterator.Create("SneakableGuardEyesAlerted", Thinker.STAT_DEFAULT - 2);
		SneakableGuardEyesAlerted mo;

		int count = 0;
		while (mo = SneakableGuardEyesAlerted(it.Next(true)))
		{
			if (Distance3d(mo) > range) { continue; }

			count++;
		}
		return count;
	}

	bool A_DoSideRoll(int dodgespeed = 10, bool checkonly = false)
	{
		if (bFriendly || dodgetimeout > 0 || target is "PatrolPoint") { return false; } // If we're still waiting after the last dodge, or are on a path, don't try to dodge right now

		double dodgeangle;
		double dodgedistance;

		[dodgedistance, dodgeangle] = GetBestSideMove(); // Get the direction (left or right) that is the best to dodge, and how far you can dodge there

		if (dodgedistance > -1) // If dodgedistance is less than zero, we shouldn't dodge...  That means there is no room.
		{
			if (checkonly) { return true; } // If this is just a logic check, stop here

			bShootable = false;
			dodgecounter++;

			// Error message if you forgot to set up the Dodge state on the actor
			if (!DodgeState) { console.printf("\cgNo Dodge sprite defined in actor " .. GetTag() .. "."); return false; }

			spriteID dodgesprite = DodgeState.sprite;
			if (dodgesprite) { sprite = dodgesprite; }

			// Set the actor's state based on dodging left or right
			if (deltaangle(dodgeangle, angle) > 0) { SetStateLabel("Dodge.Right"); }
			else { SetStateLabel("Dodge.Left"); }

			// Use the dodgeangle to move the actor in the correct direction
			VelFromAngle(dodgespeed, dodgeangle);

			// Set a random timeout (8 - 10 seconds) until another dodge is allowed
			dodgetimeout = Random(280, 350);

			return true;
		}

		return false;
	}

	double, double GetBestSideMove() //there should be some occasionally events where actors gets stucked over ledges or stairs, how to fix? - ozy81
	{
		double left = GetMoveDistance(90);
		double right = GetMoveDistance(-90);

		if (left < radius + 128 && right < radius + 128) { return -1, 0; } // Don't dodge if there's not space on either side - augmented values to avoid stuck cases
		if (left == right) return 0, angle + 90 * RandomPick(-1, 1); // If the space on either side is the same, pick a random side
		if (left > right) return left, angle + 90; // If there's more space on the left, dodge left

		return right, angle - 90; // Otherwise, dodge right
	}

	double GetMoveDistance(double angle, double range = 256)
	{
		bool blocked;

		for (double i = Radius; i <= range; i += Speed)
		{
			tracer = null;

			blocked = CheckBlock(CBF_DROPOFF | CBF_SETTRACER, AAPTR_DEFAULT, i, 0, 0, angle);

			if (blocked) { return i; }
		}

		return range;
	}

	override void Tick()
	{
		if (user_DrawHealthBar) { ChangeStatNum(Thinker.STAT_DEFAULT - 3); } // Change the statnum of these actors so that ThinkerIterators can look at just this statnum and be more efficient

		if (!globalfreeze && !level.Frozen)
		{
			if (dodgetimeout > 0) { dodgetimeout--; }

			if (swimmer && waterlevel < 3)
			{
				vel.z = min(vel.z, -1);
			}

			if (bShootable && health > 0)
			{
				if (loiterdistance > 0 && patrolgoal && !bAmbush)
				{
					if (goal && goal != patrolgoal) { } // Already has a goal set, so don't mess with it
					else if (!target || (target == patrolgoal))
					{
						if (Distance3d(patrolgoal) > loiterdistance)
						{
							goal = patrolgoal;
							target = goal;

							if (timeout <= 0)
							{
								RandomChaseDir();
								FaceMovementDirection();

								timeout = 35;
							}
						}
		 				else
						{
							goal = null;
							target = null;
						}
					}
				}
				timeout--;
			}

			if (bInConversation && marker)
			{
				marker.SetStateLabel("Inactive");
				marker = null;
			}
		}

		Super.Tick();
	}

	override void PostBeginPlay()
	{
		// After initilization, handle skill level health alterations
		//   For each each skill level below 'normal', reduce enemy health by specified percentage
		//     So, for an enemy with 25 health normally, at the second skill level, it would have 16,
		//     and at the first skill level it would have 10 (~66% of 16) (assuming the multiplier is 2/3)
		//     This effectively takes a doberman from 3 hits with the knife to 2 on skill 1, to 1 on skill 0.

		double multiplier = 2. / 3; // Cut the health down to 2/3 its value for each skill level below normal

		if (skill < 2) { // If skill 0 or 1
			int newhealth = health;

			// Reduce the health by 1/3 for each skill level below normal
			for (int i = 0; i < 2 - skill; i++) { newhealth = int(newhealth * multiplier); }

			// Set the actor's health - cap minimum at 1 so that they don't die, just in case
			A_SetHealth(max(newhealth, 1));
		}

		if (bDormant) { loiterdistance = 0; } // Don't loiter if dormant.

		// If it's a loiterer with no set goal, spawn a patrolpoint goal for it and make that the goal, then run around that point
		if (loiterdistance > 0 && !goal && !patrolgoal)
		{
			patrolgoal = Spawn("PatrolPoint", pos);
			patrolgoal.args[0] = -1;
			patrolgoal.args[1] = 0x7FFFFFFF;
			patrolgoal.angle = angle;

			SetStateLabel("See");
		}

		// If it's tagged with a conversation ID, spawn the conversation marker
		if (user_conversation && !marker)
		{
			marker = Spawn("ConversationMarker", pos);
			if (marker) { marker.master = self; }
		}

		// Initialize dodge timout delay
		DodgeState = FindState("Dodge");
		dodgetimeout = Random(175, 350);
	}
}

// Base class for almost all enemy actors.
// Adds handling for 'sneakable' actors and stealth/critical hit kills
class Nazi : Base
{
	int user_incombat;
	int perceptionthreshold;
	int perceptionfov;
	int sneakableclosesightradius;
	bool user_sneakable;
	String DeathDamageType;
	Actor activationgoal;
	int user_static;
	state AimState;
	bool healing;
	bool alerted;
	int interval;

	Property Sneakable:user_sneakable;
	Property SneakableCloseSightRadius:sneakableclosesightradius;
	Property PerceptionTime:perceptionthreshold; // How many tics the player has to be in sight before NOTARGET fails - 0 means never see through NoTarget
	Property PerceptionFOV:perceptionfov; // FOV used for NOTARGET sight checks (i.e., Gestapo and others who can see through scientist/gestapo uniforms)

	Default
	{
		Monster;
		+BOSSDEATH
		+CANBLAST //needed for kicks - ozy81
		+DONTGIB
		+DONTHARMSPECIES
		+FLOORCLIP
		+NOINFIGHTSPECIES
		+WINDTHRUST
		DamageFactor "Frag", 1.2; //increased damage from grenades & clusterbombs for Nazi related enemies - this fix TurretSoldiers [ozy81]
		DamageFactor "Trample", 2; //for truck sequences
		DamageFactor "Truck", 1.2; //for truck sequences
		Scale 0.65;
		Height 56;
		Mass 100;
		PainChance 200;
		Speed 2;
		Species "Nazi";

		Nazi.Sneakable False;
		Nazi.SneakableCloseSightRadius 64;
		Nazi.PerceptionTime 0;
		Nazi.PerceptionFOV 120;
		Base.DodgeAmount 6;
	}

	States
	{
		Look:
			"####" "#" 10 A_NaziLook();
			Loop;
		See:
		See.Normal: // Guard Walk Pattern
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" DDD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); } // Jump to the actor's defined See state so any special handling can still happen each loop
		See.Fast: // SS Walk Pattern
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" BB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" DD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.Faster: // Officer Walk Pattern
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" A 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" A 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.MutantFaster: // Mutant Walk Pattern (same as Faster, but with steps on opposite frames)
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" A 1 A_NaziChase(null, null);
			"####" A 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" A 1 A_NaziChase;
			"####" A 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" C 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.MutantFasterAlt: // Mutant Walk Pattern, offset frames (BCDE walk instead of ABCD)
			"####" "#" 0 { user_incombat = True; }
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" B 1 A_NaziChase;
			"####" B 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" C 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" D 1 A_NaziChase;
			"####" D 1 A_NaziChase(null, null);
			"####" E 1 A_NaziChase;
			"####" E 1 A_NaziChase(null, null);
			"####" E 1 A_NaziChase;
			"####" E 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.Boss: // Almost all bosses
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" B 0 A_PlaySound("floor/heavy");
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" D 0 A_PlaySound("floor/heavy");
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.BossFast: // Faster bosses, like UberMutant
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" B 0 A_PlaySound("floor/heavy");
			"####" B 1 A_NaziChase;
			"####" BB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" D 0 A_PlaySound("floor/heavy");
			"####" D 1 A_NaziChase;
			"####" DD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.BossMech: // Mechs - same as Boss, but with quake and mech sound
			"####" "#" 0 { user_incombat = True; }
			"####" A 2 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" B 0 A_PlaySound("mech/walk", CHAN_AUTO, frandom(0.7,1.0), FALSE, ATTN_IDLE);
			"####" B 2 { A_NaziChase(); Radius_Quake(5, 2, 0, 5, 0); }
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" C 2 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" D 2 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" C 0 A_PlaySound("mech/walk", CHAN_AUTO, frandom(0.5,0.7), FALSE, ATTN_IDLE);
			"####" C 2 { A_NaziChase(); Radius_Quake(5, 2, 0, 5, 0); }
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" B 2 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.BossBleeding: // Totengraber_Wounded special one
			"####" "#" 0 { user_incombat = True; }
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AAA 1 A_NaziChase(null, null);
			"####" B 0 {A_PlaySound("floor/heavy"); A_SpawnItemEx("NashGore_BloodSplasher", 0, 0, 0, frandom(-2.0, 2.0), frandom(-2.0, 2.0), frandom(1.0, 2.0), random(0, 360), SXF_TRANSFERTRANSLATION | SXF_ABSOLUTEPOSITION | SXF_ABSOLUTEANGLE | SXF_ABSOLUTEVELOCITY, 0);}
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BBB 1 A_NaziChase(null, null);
			"####" CCC 0 A_SpawnItemEx("SkullBloodDrip",8,random(-4,-8),56,0,0,0,0,0);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CCC 1 A_NaziChase(null, null);
			"####" D 0 {A_PlaySound("floor/heavy"); A_SpawnItemEx("NashGore_FlyingBlood", 0, 0, 0, frandom(0.1, 1.0) * RandomPick(-1, 1), frandom(0.1, 1.0) * RandomPick(-1, 1), frandom(0.0, 2.0), 0, SXF_TRANSFERTRANSLATION | SXF_ABSOLUTEPOSITION | SXF_ABSOLUTEANGLE | SXF_ABSOLUTEVELOCITY, 0);}
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DDD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.Frightened: // Prisoners Pattern
			"####" "#" 0 { user_incombat = True; A_SetSpeed(6);}
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" A 1 A_NaziChase;
			"####" AA 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" BB 1 A_NaziChase(null, null);
			"####" B 1 A_NaziChase;
			"####" BB 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" C 1 A_NaziChase;
			"####" CC 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" DD 1 A_NaziChase(null, null);
			"####" D 1 A_NaziChase;
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" DD 1 A_NaziChase(null, null);
			"####" A 0 { return ResolveState("See"); }
		See.Static: // Sniper Walk Pattern (non-moving, limited frame actor)
			"####" "#" 0 { user_incombat = True; }
			"####" "#" 1 A_Chase;
			"####" A 0 { return ResolveState("See"); }
		See.Dodge:
			"####" A 0 {
				bShootable = true;

				if (Random[dodgeskip]() < 144 && (!maxdodge || dodgecounter < maxdodge)) //sometimes avoid rolling
				{ // Sprite and state changes and thrusting handled internally by the A_DoSideRoll() function
					A_DoSideRoll();
				}
			}
			"####" A 0 {
				return ResolveState("Dodge.Resume"); }
		Dodge.Right:
			"####" A 0 A_SetSize(-1, Default.height / 2);
			"####" ABCDEA 5;
			"####" A 0 { return ResolveState("Dodge.End"); }
		Dodge.Left:
			"####" A 0 A_SetSize(-1, Default.height / 2);
			"####" AEDCBA 5;
			"####" A 0 { return ResolveState("Dodge.End"); }
		Dodge.End:
			"####" A 2;
			"####" A 0 {
				sprite = SpawnState.sprite;
				A_Face(target);
				A_SetSize(-1, Default.height);
				bShootable = true;
				reactiontime = 0;
			}
			"####" A 0 {
				return ResolveState("Dodge.Resume");
			}
		Dodge.Resume:
			"####" A 0 { return ResolveState("See.Normal"); }
		Idle:
			"####" AAAAAAAA 1 A_Wander;
			"####" A 0 A_Look;
			"####" BBBBBBBB 1 A_Wander;
			"####" A 0 A_Look;
			"####" CCCCCCCC 1 A_Wander;
			"####" A 0 A_Look;
			"####" DDDDDDDD 1 A_Wander;
			"####" A 0 A_Look;
			Loop;
		Pain:
			"####" H 6 A_NaziPain(256);
			"####" H 0 A_Jump(256,"See");
		MakeSneakable:
			"####" # 0 {
				if (health <= 0 || !bShootable) { return ResolveState('null'); } // If it's dead, don't make a zombie, just remove it and hope no one notices...

				user_sneakable = true;
				BeginPlay();

				return ResolveState("Spawn");
			}
		MakeAlerted:
			"####" # 0 {
				if (health <= 0 || !bShootable) { return ResolveState('null'); } // If it's dead, don't make a zombie, just remove it and hope no one notices...

				BecomeAlerted(target);
				return ResolveState("See");
			}
		Alarm:
			"####" H 50 A_SetTics(interval);
			"####" H 0 A_Jump(256, "See");
	}

	// Function to consolidate default pain state actions.  See use above - can be used to eliminate a lot of existing copy/paste.
	void A_NaziPain(int alertrange = 0, bool playsound = True, int offset = -8)
	{
		A_SpawnItemEx("Pain_Overlay", scale.x + 3, 0, height + offset, 0, 0, 0, 0, SXF_NOCHECKPOSITION | SXF_USEBLOODCOLOR); // Spawn pain overlay blood spurt
		if (alertrange) { A_AlertMonsters(alertrange); } // Alert monsters in given range
		if (playsound) { A_Pain(); } // Play pain sound unless passed 'false'

		if (user_sneakable && bFriendly) // If we attacked a sneakable actor who wasn't alerted...
		{
			BecomeAlerted(target); // Alert that actor
		}
	}

	void A_NaziLook()
	{
		A_Look();

		// Check specifically for players via CheckSight in order to "see through" block-everything lines (which are usually windows)
		for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and see if any are in sight
		{
			if (players[p].cheats & CF_NOTARGET) { continue; }

			Actor mo = players[p].mo;

			if (mo) {
				if (IsFriend(mo)) { continue; }
				if (Distance3d(mo) > 160.0) { continue; }
				if (abs(deltaangle(angle, AngleTo(mo))) > 32.5) { continue; }
				if (!CheckSight(mo, SF_SEEPASTBLOCKEVERYTHING | SF_SEEPASTSHOOTABLELINES)) { continue; }

				target = mo;
				SetStateLabel("See");
			}
		}
	}

	void A_NaziChase(statelabel melee = "None", statelabel missile = "None", int flags = 0)
	{
		if (melee == "None") { melee = "Melee.Aimed"; }
		if (missile == "None") { missile = "Missile.Aimed"; }

		if (target && Distance3D(target) < 256) { user_static = 0; }

		if (AimState && (user_static || bAmbush))
		{
			flags |= CHF_DONTMOVE | CHF_NODIRECTIONTURN;

			frame = AimState.frame;
			A_SetTics(Random[StandDelay](1, 5));

			A_FaceTarget();
			reactiontime = 0;
		}

		if (user_sneakable && bFriendly && level.time && level.time % interval == 0) { A_LookForBodies(); }

		A_Chase(melee, missile, flags);
	}

	virtual state A_LookForBodies()
	{
		if (goal && goal is "PatrolPoint")
		{
			patrolgoal = goal; // Save the navigation goal if one was set
		}

		if (!patrolgoal) // Otherwise, make a new navgoal at the actor's origin so that it can come back.
		{
			patrolgoal = Spawn("PatrolPoint", pos);
			patrolgoal.args[0] = -1;
			patrolgoal.args[1] = 0x7FFFFFFF;
			patrolgoal.angle = angle;
		}

		ThinkerIterator Finder = ThinkerIterator.Create("Nazi", STAT_DEFAULT - 5);
		Nazi mo;

		while ( (mo = Nazi(Finder.Next())) )
		{
			if (!IsCorpse(mo)) { continue; }

			if (goal && Distance3d(mo) > Distance3d(goal)) { continue; }

			goal = mo;
		}

		// A Second iterator to account for the non-sneakables...
		Finder = ThinkerIterator.Create("Nazi", STAT_DEFAULT);

		while ( (mo = Nazi(Finder.Next())) )
		{
			if (!IsCorpse(mo)) { continue; }

			if (goal && Distance3d(mo) > Distance3d(goal)) { continue; }

			goal = mo;
		}

		if (goal && (goal is "Nazi"))
		{
			Speed = Default.Speed + 1; // Walk a little faster
			if (Distance3D(goal) < 96)
			{
				BecomeAlerted(goal.target);
			}
		}

		return ResolveState(null);
	}

	bool IsCorpse(Actor mo)
	{
		if (
			!mo.bIsMonster ||
			mo.health > 0 ||
			mo.bDormant ||
			Distance3d(mo) > 512
		) { return false; }

		return true;
	}

	// Initialize actor
	override void BeginPlay()
	{
		// If it's sneakable, spawn a set of the sneakeable eyes and mark it as friendly (and make the actor never infight)
		if (user_sneakable) {
			bFriendly = True;
			bNeverTarget = True; // A bit of a hack, but it works...  Will cause issues if FRIENDLY actors ever need to interact with sneakable actors
			A_SpawnItemEx("SneakableGuardEyesIdle", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid);
			ChangeStatNum(Thinker.STAT_DEFAULT - 5); // Make these tic before the alert lights for checking logic purposes
		}
		else if (SneakableActors()) // If there are sneakable actors in the level, no Nazi actors will be targetable - fixes targeting of non-sneakables by idle (friendly) sneakables
		{ // This will break normal expected friendly monster behavior!
			bNeverTarget = True;
		}

		// Set the actor's aim state (first frame of attack animation) for static and AMBUSH actors
		AimState = FindState("Missile.Aimed");
		if (!AimState) { AimState = FindState("Melee.Aimed"); }

		interval = Random[pollinterval](35, 70);
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		// Use the aim state frame as the initial frame if they have the AMBUSH flag
		if (AimState && bAmbush) { frame = AimState.frame; }
	}

	// Hijack the damage calls in order to implement stealth kills and critical hits
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags = 0, double angle = 0)
	{
		Inventory vis;

		if (user_sneakable && bDormant) { bDormant = False; } // Pain wakes up a dormant sneakable actors

		String currentDamage = (inflictor && inflictor.paintype) ? inflictor.paintype : mod; // Get the damage type

		if (currentDamage ~== "SilentKnifeAttack" && !bBoss) // If the attack was with the knife (and this is not a boss actor - they can't be one-hit killed!)
		{
			if (user_sneakable && bFriendly) // If this is a sneakable actor who isn't active yet
			{ // Stealth kill, remove the sneakable eyes, alert a medium radius, and kill the actor
				A_Log(StringTable.Localize("$STEALTH"));
				A_RemoveChildren(TRUE, RMVF_EVERYTHING);
				bFriendly = False; // Force to not friendly so that they will count as a kill and be healable.
				SoundAlert(source, false, 192);
				A_Die();
			}
			else if (user_incombat) // If the actor has already been in its See state
			{
				A_PlaySound("Nazi1/Pain", CHAN_AUTO, FRandom(0.2, 0.4), FALSE, ATTN_NORM); // Play quiet pain sound
				SoundAlert(source, false, 64); //ozy - only if near // Alert small radius
			}
			else // Otherwise, this attack was the equivalent of Stealth Kill for non-sneakable enemies
			{
				user_incombat = True;
				A_Log(StringTable.Localize("$CRITICAL"));
				SoundAlert(source, false, 192);
				A_Die();
			}
		}

		if (source) { vis = source.FindInventory("BoAVisibility"); }

		if (vis) { BoAVisibility(vis).visibility = 200; }

		if (user_sneakable && bFriendly) // If we attacked a sneakable actor who wasn't alerted...
		{
			BecomeAlerted(source); // Alert that actor
		}

		int damageamt = Super.DamageMobj(inflictor, source, damage, mod, flags, angle); // Get the damage amount from the real DamageMobj function

		if (damageamt >= health) // If we killed the actor...
		{
			if (user_sneakable) // and it was a sneakable actor...
			{
				A_RemoveChildren(TRUE, RMVF_EVERYTHING); // Remove the sneakable eyes
			}

			if (perceptionthreshold > 0) // or if it was a perceptive actor...
			{
				if (vis) { BoAVisibility(vis).suspicion = 0; } // Reset suspicion level to zero
			}

			DeathDamageType = currentDamage;
		}

		if (source is "PlayerPawn") { target = source; } // Set the attacker as the current target

		return damageamt; // Function returns amount of damage received by the actor
	}

	// Handling for alerting sneakable actors
	void BecomeAlerted(Actor newtarget = null)
	{
		if (health <= 0 || !bShootable) { return; } // If it's dead, don't do anything

		if (!alerted)
		{
			A_SpawnItemEx("AlertMarker", 0, 0, 64, 0, 0, 0, 0, SXF_SETMASTER);
			if (!bBoss) { A_PlaySound("axis1/sighted", CHAN_BODY); }
			else { A_PlaySound(SeeSound, CHAN_BODY); }

			dodgetimeout = Random(175, 350);
			dodgecounter = 0;

			alerted = true;
		}

		A_RemoveChildren(TRUE, RMVF_EVERYTHING, "None", "Eyes"); // Get rid of the passive guard eyes
		bFriendly = False; // Set unfriendly

		if (goal)
		{
			if (goal is "PatrolPoint")
			{
				patrolgoal = goal; // Save the navigation goal if one was set
			}
			else { goal = null; }
		}

		if (!patrolgoal) // Otherwise, make a new navgoal at the actor's origin so that it can come back.
		{
			patrolgoal = Spawn("PatrolPoint", pos);
			patrolgoal.args[0] = -1;
			patrolgoal.args[1] = 0x7FFFFFFF;
			patrolgoal.angle = angle;
		}

		target = newtarget; // Set target to the player the eyes saw

		if (activationgoal)
		{
			goal = activationgoal;
			target = activationgoal;
			LastEnemy = newtarget;
			bChaseGoal = True;
		}

		Speed = Default.Speed;
		reactiontime = 0; // Make the enemy respond to seeing the player right away
		A_AlertMonsters(512); // Alert an extra-large radius
		A_SpawnItemEx("SneakableGuardEyesAlerted", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid); // Spawn active guard eyes
		if (target && target.GetSpecies() == GetSpecies()) { target = null; SetStateLabel("Spawn"); } // Don't go after same-species targets

		SetStateLabel("See"); // Go to See state and start chasing the player (or wandering if target wasn't set for some reason)
	}

	void BecomeIdle()
	{
		if (health <= 0 || !bShootable) { return; }

		A_RemoveChildren(TRUE, RMVF_EVERYTHING, "None", "Eyes"); // Get rid of the active guard eyes
		bFriendly = True;

		goal = patrolgoal; // Restore any navigation goal if there was one set
		target = patrolgoal;

		A_SpawnItemEx("SneakableGuardEyesIdle", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid);

		sprite = SpawnState.sprite;

		if (goal && target) { SetStateLabel("See"); }
		else { SetStateLabel("Spawn"); }
	}

	void A_UnblockAndDrop()
	{
		if (user_ForceWeaponDrop)
		{
			DropItem drops = GetDropItems();
			DropItem item;

			if (drops != null)
			{
				for (item = drops; item != null; item = item.Next)
				{
					String itemName = String.Format("%s", item.Name); // Don't know why I have to do this and the Length check, but 'DropItem ""' crashes without it, even if I check for != "", != null, etc...
					if (itemName.Length() > 0 && item.Name != 'None')
					{
						Actor drop = Spawn(item.Name); // See if it spawns in order to validate the name...  Since there's no FindClass function exposed?

						if (drop is "Weapon") // If it is a weapon, drop the item
						{
							int amt = item.Amount;

							A_DropItem(item.Name, amt);
						}

						drop.Destroy(); // Destroy the placeholder spawned item
					}
				}
			}

			A_NoBlocking(False); // Set A_NoBlocking with no additional item drops.
		}
		else if (user_sneakable)
		{
			DropItem drops = GetDropItems();
			DropItem item;

			double dropfactor = G_SkillPropertyFloat(SKILLP_DropAmmoFactor);
			if (dropfactor < 0) { dropfactor = 0.5; }

			if (drops != null)
			{
				for (item = drops; item != null; item = item.Next)
				{
					String itemName = String.Format("%s", item.Name); // Don't know why I have to do this and the Length check, but 'DropItem ""' crashes without it, even if I check for != "", != null, etc...
					if (itemName.Length() > 0 && item.Name != 'None')
					{
						Actor drop = Spawn(item.Name); // See if it spawns in order to validate the name...  Since there's no FindClass function exposed?

						int amt = item.Amount;

						if (Weapon(drop)) // Only drop weapons, no extra ammo, grenades, etc.
						{
							if (amt <= 0)
							{
								amt = Weapon(drop).AmmoGive1 > 0 ? Weapon(drop).AmmoGive1 : Weapon(drop).AmmoGive2; // Default to affecting AmmoType1, with fallback to AmmoType2
								amt = max(int(amt * (dropfactor / 2)), 0); // Worst case, drop a weapon with zero ammo
							}

							A_DropItem(item.Name, amt);
						}

						drop.Destroy(); // Destroy the placeholder spawned item
					}
				}
			}

			A_NoBlocking(False); // Set A_NoBlocking with no additional item drops.
		}
		else
		{
			A_NoBlocking(True); // Otherwise, unblock and do normal drops
		}
	}

	override void Tick()
	{
		// If the enemy is sneakable and idle (and not patrolling), and isn't in its original location, keep it moving toward that location.
		//  NOTE: This doesn't work properly when the player has NOTARGET enabled (or is wearing a disguise and has no weapon raised).
		if (health > 0 && bShootable)
		{
			if (user_sneakable && bFriendly && patrolgoal && patrolgoal.args[0] == -1)
			{
				MeleeRange = 0; // To bypass the internal A_Chase "goal reached" logic

				if (Distance3D(patrolgoal) <= Radius) // If at goal, clear target and goal and go to Spawn state
				{
					angle = patrolgoal.angle;
					goal = null;
					LastHeard = null;
					LastEnemy = null;
					A_ClearTarget();
					MeleeRange = Default.MeleeRange;
					SetStateLabel("Spawn");
				}
				else // Otherwise, keep trying to get there (necessary because A_Chase clears goal and target when within MeleeRange of goal)
				{
					goal = patrolgoal;
					target = patrolgoal;
					if (!InStateSequence(CurState, SeeState)) { SetStateLabel("See"); }
				}
			}
			else if (!bFriendly && activationgoal)
			{
				MeleeRange = 0; // To bypass the internal A_Chase "goal reached" logic

				if (Distance3D(activationgoal) <= Radius + activationgoal.radius)
				{
					A_Face(activationgoal);

					if (LastEnemy is "PlayerPawn") { target = LastEnemy; }
					LastEnemy = null;

					bJustAttacked = False;
					bChaseGoal = False;
					Speed = Default.Speed;

					MeleeRange = Default.MeleeRange;

					if (activationgoal is "AlarmPanel") { SetStateLabel("Alarm"); }

					activationgoal.Activate(target);

					activationgoal = null;
				}
				else // Otherwise, keep trying to get there
				{
					goal = activationgoal; // Set the activation goal as the current navigation goal
					bJustAttacked = True; // Keep the actor from attacking while chasing to the goal
					bChaseGoal = True; // Chase to the goal only, not toward a target
					Speed = Default.Speed + 1; // Walk a little faster
					if (!InStateSequence(CurState, SeeState)) { SetStateLabel("See"); } // Go to the See state if not already there
				}
			}
		}

		Super.Tick();
	}
}

//Standard Nazi enemy defaults.
//  Intended for use with 'normal' non-boss Nazi enemies.
//  Currently handles burning, gibbing, and disintegration states
class NaziStandard : Nazi
{
	Default
	{
		GibHealth 30;
		SeeSound "Nazi1/Sighted";
		PainSound "Nazi1/Pain";
		DeathSound "Nazi1/Death";
	}

	States
	{
		Salute: //special state for cinematic sequences - ozy81
			"####" N 35;
		SaluteLoop:
			"####" Z 35;
			Loop;
		Death.Fire:
			"####" # 0 A_SetScale(0.55);
		Death.Fire.Random: // Jump to here if you have an actor that needs a different scale set (See WereWaffenSS)
			"####" # 0 {
				DeathDamageType = "Fire"; // Because the flamethrower guards are set to this state via jump, not damage
				sprite = GetSpriteIndex(Random() < 128 ? "BURN" : "NRUB");
				bIsMonster = False; // Burned enemies can't be resurrected
			}
			"####" A 5 Bright Light("ITBURNS1") { A_Wander(); }
			"####" BC 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" D 5 Bright Light("ITBURNS1") { A_Wander(); A_PlaySound("death/burning"); }
			"####" E 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" FABCD 5 Bright Light("ITBURNS2") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" EFAG 5 Bright Light("ITBURNS3") A_Wander();
			"####" H 5 Bright Light("ITBURNS3") A_UnblockAndDrop();
			"####" IJK 5 Bright Light("ITBURNS2") { A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,16), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" LMN 5 Bright Light("ITBURNS1") { A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,8), 1, 0, random (1, 3), frandom (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
		Death.Fire.Smoke:
			"####" O 0 A_Jump(32,"Death.Fire.End");
			"####" O 2 Light("ITBURNS4") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 4 Light("ITBURNS5") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 3 Light("ITBURNS6") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 5 Light("ITBURNS5") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			Loop;
		Death.Fire.End:
			"####" O -1;
			Stop;
		Raise:
			"####" M 35;
			"####" LKJ 5;
			"####" I 5 A_Jump(256,"See");
			Stop;
		XDeath:
			SLOP A 5 {
				A_SpawnItemEx("NashGore_FlyingBlood", 0, 0, 8, random(-4, 4), random(-4, 4), random(2, 5), 0, 143, 176);
				A_SetScale(0.65);
				bIsMonster = False; // So that an exploded enemy can't be resurrected
			}
			"####" BCDE 5;
			"####" F 5 A_UnblockAndDrop();
			"####" G -1;
			Stop;
		Disintegrate:
			"####" H 5 {
				A_Scream();
				A_Playsound("astrostein/guard_death");
				A_UnblockAndDrop();
				A_SpawnItemEx("BaseLine", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
			}
		Disintegrate.FadeLoop:
			"####" "#" 1 A_FadeOut(0.02);
			Loop;
		Disintegrate.Alt1: //added in case we plan to have allied soldiers on Astrostein maps - ozy81
			"####" I 5 {
				A_Scream();
				A_Playsound("astrostein/guard_death");
				A_UnblockAndDrop();
				A_SpawnItemEx("BaseLine", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
			}
			"####" I 0 A_Jump(256,"Disintegrate.FadeLoop");
			Stop;
		Disintegrate.Alt2:
			"####" J 5 {
				A_Scream();
				A_Playsound("astrostein/guard_death");
				A_UnblockAndDrop();
				A_SpawnItemEx("BaseLine", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
			}
			"####" J 0 A_Jump(256,"Disintegrate.FadeLoop");
			Stop;
		SpriteLookups: // Because the GetSpriteIndex function won't find sprites that aren't already used by a state in the current actor.
			BURN A 0;
			NRUB A 0;
	}
}

class MutantStandard : Nazi
{
	Default
	{
		Scale 0.7;
		GibHealth 30;
		DamageFactor "MutantPoison", 0;
		DamageFactor "UndeadPoison", 0;
		DamageFactor "Poison", 0;
		SeeSound "mutant/see";
		PainSound "mutant/pain";
		DeathSound "mutant/Death";
		BloodColor "Purple";
		BloodType "MutantBlood";
		Translation "16:47=[205,0,215]:[40,0,96]","168:191=[205,0,215]:[40,0,96]";
	}

	States
	{
		Death.Fire:
			"####" # 0 A_SetScale(0.55);
		Death.Fire.Random: // Jump to here if you have an actor that needs a different scale set (See WereWaffenSS)
			"####" # 0 {
				DeathDamageType = "Fire"; // Because the flamethrower guards are set to this state via jump, not damage
				sprite = GetSpriteIndex(Random() < 128 ? "BURN" : "NRUB");
				bIsMonster = False; // Burned enemies can't be resurrected
			}
			"####" A 5 Bright Light("ITBURNS1") { A_Wander(); }
			"####" BC 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" D 5 Bright Light("ITBURNS1") { A_Wander(); A_PlaySound("mutant/Death"); }
			"####" E 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" FABCD 5 Bright Light("ITBURNS2") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" EFAG 5 Bright Light("ITBURNS3") A_Wander();
			"####" H 5 Bright Light("ITBURNS3") A_UnblockAndDrop();
			"####" IJK 5 Bright Light("ITBURNS2") { A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,16), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" LMN 5 Bright Light("ITBURNS1") { A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,8), 1, 0, random (1, 3), frandom (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
		Death.Fire.Smoke:
			"####" O 0 A_Jump(32,"Death.Fire.End");
			"####" O 2 Light("ITBURNS4") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 4 Light("ITBURNS5") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 3 Light("ITBURNS6") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 5 Light("ITBURNS5") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			Loop;
		Death.Fire.End:
			"####" O -1;
			Stop;
		Raise:
			"####" M 35;
			"####" LKJ 5;
			"####" I 5 A_Jump(256,"See");
			Stop;
		XDeath:
			SLOM A 5 {
				A_SpawnItemEx("MutantFlyingBlood", 0, 0, 8, random(-4, 4), random(-4, 4), random(2, 5), 0, 143, 176);
				A_SetScale(0.62);
				bIsMonster = False; // So that an exploded enemy can't be resurrected
			}
			"####" BCDE 5;
			"####" F 5 A_UnblockAndDrop();
			"####" G -1;
			Stop;
		XDeath.Big:
			SLOM A 5 {
				A_SpawnItemEx("MutantFlyingBlood", 0, 0, 8, random(-4, 4), random(-4, 4), random(2, 5), 0, 143, 176);
				A_SetScale(0.95);
				bIsMonster = False; // So that an exploded enemy can't be resurrected
			}
			Goto XDeath+1;
		Disintegrate:
			"####" H 5 {
				A_Scream();
				A_Playsound("astrostein/guard_death");
				A_UnblockAndDrop();
				A_SpawnItemEx("BaseLine", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
			}
		Disintegrate.FadeLoop:
			"####" H 1 A_FadeOut(0.02);
			Loop;
		SpriteLookups: // Because the GetSpriteIndex function won't find sprites that aren't already used by a state in the current actor.
			BURN A 0;
			NRUB A 0;
	}
}

//Standard Zombie enemy defaults.
class ZombieStandard : Nazi
{
	Default
	{
		GibHealth 30;
		PainChance 64;
		DamageFactor "Fire", 1.2;
		DamageFactor "MutantPoison", 0;
		DamageFactor "Normal", 0.5;
		DamageFactor "Poison", 0;
		DamageFactor "UndeadPoison", 0;
		SeeSound "nazombie/sighted";
		PainSound "nazombie/pain";
		DeathSound "sscultist/die";
		BloodColor "Black";
		BloodType "UndeadBlood";
		Translation "16:47=[34,0,7]:[0,0,0]","168:191=[36,0,9]:[2,0,0]";
	}

	States
	{
		Death.Fire:
			"####" # 0 A_SetScale(0.55);
		Death.Fire.Random: // Jump to here if you have an actor that needs a different scale set (See WereWaffenSS)
			"####" # 0 {
				DeathDamageType = "Fire"; // Because the flamethrower guards are set to this state via jump, not damage
				sprite = GetSpriteIndex(Random() < 128 ? "BURN" : "NRUB");
				bIsMonster = False; // Burned enemies can't be resurrected
			}
			"####" A 5 Bright Light("ITBURNS1") { A_Wander(); }
			"####" BC 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" D 5 Bright Light("ITBURNS1") { A_Wander(); A_PlaySound("sscultist/die"); }
			"####" E 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" FABCD 5 Bright Light("ITBURNS2") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" EFAG 5 Bright Light("ITBURNS3") A_Wander();
			"####" H 5 Bright Light("ITBURNS3") A_UnblockAndDrop();
			"####" IJK 5 Bright Light("ITBURNS2") { A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,16), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
			"####" LMN 5 Bright Light("ITBURNS1") { A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,8), 1, 0, random (1, 3), frandom (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
		Death.Fire.Smoke:
			"####" O 0 A_Jump(32,"Death.Fire.End");
			"####" O 2 Light("ITBURNS4") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 4 Light("ITBURNS5") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 3 Light("ITBURNS6") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			"####" O 5 Light("ITBURNS5") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
			Loop;
		Death.Fire.End:
			"####" O -1;
			Stop;
		Disintegrate:
			"####" H 5 {
				A_Scream();
				A_Playsound("astrostein/guard_death");
				A_UnblockAndDrop();
				A_SpawnItemEx("BaseLine", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
			}
		Disintegrate.FadeLoop:
			"####" H 1 A_FadeOut(0.02);
			Loop;
		SpriteLookups: // Because the GetSpriteIndex function won't find sprites that aren't already used by a state in the current actor.
			BURN A 0;
			NRUB A 0;
	}
}

// Conversation marker that follows the actor, positioning itself above their head.
//  For Invisible/NoBlockMap actors, the marker is placed at the base of the actor.
class ConversationMarker : Actor
{
	Default
	{
		+BRIGHT
		+NOBLOCKMAP
		+NOGRAVITY
		Height 0;
		Radius 0;
		Scale 1.35;
		RenderStyle "Translucent";
		Alpha 1.0;
	}

	States
	{
		Spawn:
		Active:
			EXCL D 1;
			Loop;
		Inactive:
			EXCL D 10;
			EXCL E -1;
			Stop;
	}

	override void Tick()
	{
		if (master)
		{
			if (master.health <= 0 || !Base(master).user_conversation) { Destroy(); }
			else
			{
				double offset;

				if (master.bInvisible || master.bNoBlockMap) { offset = 12; }
				else { offset = master.height + 12; }

				SetOrigin((master.pos.x, master.pos.y, master.pos.z + offset), true);
			}
		}

		Super.Tick();
	}
}